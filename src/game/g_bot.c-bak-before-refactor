/*
   ===========================================================================
   Copyright (C) 2007 Amine Haddad

 ** This file is modified by Thomas Rinsma, I take no copyright at all

   This file is part of Tremulous.

   The original works of vcxzet (lamebot3) were used a guide to create TremBot.

   Tremulous is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the License,
   or (at your option) any later version.

   Tremulous is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Tremulous; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
   ===========================================================================
 */

/* Current version: v0.02-COW6 */

/*
   [ChangeLog]
   (v0.02-COW6)
   Bots can now roam around the map freely thanks to PBot - Fuma
   Bots can now find a path to a target (friend, enemy, building, whatever) around obstacales using the waypoints. This is all me :). - Fuma
   
   
   (v0.02-COW5)
   Fixed bots not getting close enough to attack base with flamer/psaw - Fuma
   Rewrote botFindClosestEnemy so it acually does find the **closest** enemy -.- - Fuma
   Imported improved botAimAtTarget code from PBot - Fuma
   Added the "shoot at head" improvement that was in previous botAimAtTarget to new botAimAtTarget - Fuma
   Consequence of the new botAimAtTarget code: MUCH better implementation of bot skillLevel - Fuma
   Removing the bot jump/crouch code caused problems too, so I added it back, but they can only crouch of their target is a buildable. - Fuma
   Bots can now buy a psaw - Fuma
   Renamed botIsStructureBlocking to the more apt botPathIsBlocked and rewrote implementation to be more robust - Fuma
   Bots can now use luci's primary fire.... BEWARE!! - Fuma
   Bots will now TK structures if set to teamkill mode - Fuma
   Bots will now buy a battpack for energy weapons - Fuma
   Dragoons can pounce and use barbs now (PBot code) - Fuma
   Rants can use charge (PBot code) - Fuma
   Flamers wont fire until close enough (PBot code) - Fuma
   
   (v0.02-COW4)
   Fixed weird bug we saw with human bots in the first test on server, moving erractically - Fuma
   Added simple implementation of bot skill level - Fuma
   Bots now attempt to jump over structures in their way - Fuma
   Human bots are smarter when attacking structures, they now stand in place instead of rushing to their doom - Fuma
   Removed the ability for human bots to crouch because it was both pointless and caused problems - Fuma
   Removed the ability for human bots to jump when aiming high enough because it was both pointless and caused problems - Fuma
   Added cvars to control what bots can buy - Fuma
   Alien bots no longer TK on accident - Fuma
   **Improved** the bot movement code to be less predictable -Fuma
   
   (v0.02-COW3)
   Fixed human buy bug, human ckits could not repair arms because their ckit was swapped for weapon - Fuma
   Made bots able to buy helmet and light armor - Fuma
   Made bots head towards medistat when damaged and no enemies in sight and no structures damaged/no ckit - Fuma
   Added option to prevent bots from attacking buildings - Fuma

   (v0.02-COW2)
   Made bots with weapons switch to blaster when out of ammo - Fuma
   Added code to prevent putting bots with weapons in repair mode - Fuma
   Uncommented alien evolve code, and wrapped in an if with cvar g_bot_evolve to turn on/off - Fuma
   Uncommented human buy code, and wrapped in an if with cvar g_bot_buy to turn on/off - Fuma
   Fixed oversight where bots would not retain commands after death - Fuma
   Removed definitions at top as they are now in g_local.h - Fuma

   (v0.02-COW1)
   Added auto command to make bots repair automatically - Fuma
   Added spawnrifle and spawnckit commands to control which weapon bots spawn with - Fuma

   (v0.02)
   (rc1)Rewrote botAimAtTarget, now aims at enemy head - amine
   (rc1)Fixed bug where it crashes when botEnemy/botFriend are NULL and botThink executes - amine
   (rc1)Fixed bug where grenade wasn't disabled - amine

   (v0.01)
   Initial Release - amine

*/

#include "g_local.h"

#ifndef RAND_MAX
#define RAND_MAX 32768
#endif


// TODO: Create header file

int prev[MAX_PATHS];

void G_BotAdd( char *name, int team, int skill ) {
    int i;
    int clientNum;
    char userinfo[MAX_INFO_STRING];
    int reservedSlots = 0;
    gentity_t *bot;
    //char buffer [33];
    reservedSlots = trap_Cvar_VariableIntegerValue( "sv_privateclients" );

    // find what clientNum to use for bot
    clientNum = -1;
    for( i = 0; i < reservedSlots; i++ ) {
        if( !g_entities[i].inuse ) {
            clientNum = i;
            break;
        }
    }

    if(clientNum < 0) {
        trap_Printf("no more slots for bot\n");
        return;
    }

    //clientNum = trap_BotAllocateClient();

    //no slots available
    //if( clientNum == -1 )
    //return;
    //char buffer;
    //buffer = (char) clientNum + 48;
    //iota( clientNum, buffer, 10);
    //trap_Printf(va("clientNum = %s\n",clientNum + ""));
    bot = &g_entities[ clientNum ];
    //bot->client = &level.clients[ clientNum ];
    bot->r.svFlags |= SVF_BOT;
    bot->inuse = qtrue;


    //default bot data
    bot->botCommand = BOT_AUTO;
    bot->botFriend = NULL;
    bot->botEnemy = NULL;
    bot->botFriendLastSeen = 0;
    bot->botEnemyLastSeen = 0;
    bot->botSkillLevel = skill;
    bot->botTeam = team;
    bot->spawnItem = WP_HBUILD;
    bot->pathChosen = qfalse;
    bot->nextNode = qfalse;
    bot->state = FINDNEWPATH;

    // register user information
    userinfo[0] = '\0';
    Info_SetValueForKey( userinfo, "name", name );
    Info_SetValueForKey( userinfo, "rate", "25000" );
    Info_SetValueForKey( userinfo, "snaps", "20" );

    trap_SetUserinfo( clientNum, userinfo );

    // have it connect to the game as a normal client
    if(ClientConnect(clientNum, qtrue) != NULL )
        // won't let us join
        return;

    ClientBegin( clientNum );
    G_ChangeTeam( bot, team );
}

void G_BotDel( int clientNum ) {
    gentity_t *bot;

    bot = &g_entities[clientNum];
    if( !( bot->r.svFlags & SVF_BOT ) ) {
        trap_Printf( va("'^7%s^7' is not a bot\n", bot->client->pers.netname) );
        return;
    }

    ClientDisconnect(clientNum);
    //trap_BotFreeClient(clientNum);
}

void G_BotCmd( gentity_t *master, int clientNum, char *command, qboolean admincmd) {
    gentity_t *bot;

    bot = &g_entities[clientNum];
    if( !( bot->r.svFlags & SVF_BOT ) )
        return;

    bot->botFriend = NULL;
    bot->botEnemy = NULL;
    bot->botFriendLastSeen = 0;
    bot->botEnemyLastSeen = 0;

    if( !Q_stricmp( command, "regular" ) )
        bot->botCommand = BOT_REGULAR;
        //trap_SendServerCommand(-1, "print \"regular mode\n\"");
    else if( !Q_stricmp( command, "idle" ) )
        bot->botCommand = BOT_IDLE;
        //trap_SendServerCommand(-1, "print \"idle mode\n\"");
    else if( !Q_stricmp( command, "attack" ) )
        bot->botCommand = BOT_ATTACK;
        //trap_SendServerCommand(-1, "print \"attack mode\n\"");
    else if( !Q_stricmp( command, "standground" ) )
        bot->botCommand = BOT_STAND_GROUND;
        //trap_SendServerCommand(-1, "print \"stand ground mode\n\"");
    else if( !Q_stricmp( command, "defensive" ) ) {
        bot->botCommand = BOT_DEFENSIVE;
	bot->botDefensePoint = bot->s.pos.trBase;
    }
        //trap_SendServerCommand(-1, "print \"defensive mode\n\"");
    else if( !Q_stricmp( command, "followprotect" ) ) {
        bot->botCommand = BOT_FOLLOW_FRIEND_PROTECT;
        bot->botFriend = master;
        //trap_SendServerCommand(-1, "print \"follow-protect mode\n\"");
    } else if( !Q_stricmp( command, "followattack" ) ) {
        //if((admincmd || !bot->botFriend) && bot->botFriend != master) {
        bot->botCommand = BOT_FOLLOW_FRIEND_ATTACK;
        bot->botFriend = master;
        /*if( !admincmd )
            
            G_Say( bot, NULL, SAY_TEAM, "Ok");*/
        //trap_SendServerCommand(-1, "print \"follow-attack mode\n\"");
    } else if( !Q_stricmp( command, "followidle" ) ) {
        bot->botCommand = BOT_FOLLOW_FRIEND_IDLE;
        bot->botFriend = master;
        //trap_SendServerCommand(-1, "print \"follow-idle mode\n\"");
    } else if( !Q_stricmp( command, "teamkill" ) )
        bot->botCommand = BOT_TEAM_KILLER;
        //trap_SendServerCommand(-1, "print \"team kill mode\n\"");
    else if( !Q_stricmp( command, "repair" ) ) {
        bot->botCommand = BOT_REPAIR;
        G_ForceWeaponChange( bot, WP_HBUILD );
        //trap_SendServerCommand(-1, "print \"repair mode\n\"");
    } else if( !Q_stricmp( command, "auto" ) )
        bot->botCommand = BOT_AUTO;
    else if( !Q_stricmp( command, "spawnrifle" ) )
        bot->spawnItem = WP_MACHINEGUN;
    else if( !Q_stricmp( command, "spawnckit" ) )
        bot->spawnItem = WP_HBUILD;
        /* } else if( !Q_stricmp( command, "evolve" ) && bot->client->pers.teamSelection == PTE_ALIENS ) {
             if( !Q_stricmp( command2, "basi" )) {
                 G_BotEvolve(bot, "level1");
             } else if( !Q_stricmp( command2, "mara" )) {
                 G_BotEvolve(bot, "level2");
             } else if( !Q_stricmp( command2, "goon" )) {
                 G_BotEvolve(bot, "level3");
             } else {
                 trap_SendServerCommand( -1, va( "print \"Available options to evolve are: basi, mara, goon\n\"") );
             }*/

    else {
        bot->botCommand = BOT_AUTO;
        trap_SendServerCommand(-1, "print \"Unknown mode. Reverting to auto.\n\"");
    }
    return;
}

int G_BotBuyUpgrade ( gentity_t *ent, int upgrade )
{
    //already got this?
    if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
        return 0;

    //can afford this?
    if( BG_FindPriceForUpgrade( upgrade ) > (short)ent->client->ps.persistant[ PERS_CREDIT ] )
        return 0;

    //have space to carry this?
    if( BG_FindSlotsForUpgrade( upgrade ) & ent->client->ps.stats[ STAT_SLOTS ] )
        return 0;

    //are we /allowed/ to buy this?
    if( !BG_FindPurchasableForUpgrade( upgrade ) )
        return 0;

    //are we /allowed/ to buy this?
    if( !BG_FindStagesForUpgrade( upgrade, g_humanStage.integer ) || !BG_UpgradeIsAllowed( upgrade ) )
        return 0;

    if( upgrade == UP_AMMO )
        G_GiveClientMaxAmmo( ent, qfalse );
    else
        //add to inventory
        BG_AddUpgradeToInventory( upgrade, ent->client->ps.stats );

    if( upgrade == UP_BATTPACK )
        G_GiveClientMaxAmmo( ent, qtrue );

    //subtract from funds
    G_AddCreditToClient( ent->client, -(short)BG_FindPriceForUpgrade( upgrade ), qfalse );

    return 1;
}

int G_BotBuy ( gentity_t *ent, int weapon )
{
    int maxAmmo, maxClips;

    //already got this?
    if( BG_InventoryContainsWeapon( weapon, ent->client->ps.stats ) )
        return 0;

    //can afford this?
    if( BG_FindPriceForWeapon( weapon ) > (short)ent->client->ps.persistant[ PERS_CREDIT ] )
        return 0;

    //have space to carry this?
    if( BG_FindSlotsForWeapon( weapon ) & ent->client->ps.stats[ STAT_SLOTS ] )
        return 0;

    //are we /allowed/ to buy this?
    if( !BG_FindPurchasableForWeapon( weapon ) )
        return 0;

    //are we /allowed/ to buy this?
    if( !BG_FindStagesForWeapon( weapon, g_humanStage.integer ) || !BG_WeaponIsAllowed( weapon ) )
        return 0;
    
    //does server allow us to buy this?
    switch(weapon) {
	case WP_MACHINEGUN:
	    if(g_bot_rifle.integer == 0)
		return 0;
	    break;
	case WP_PAIN_SAW:
	    if(g_bot_psaw.integer == 0)
		return 0;
            break;
	case WP_SHOTGUN:
	    if(g_bot_shotgun.integer == 0)
		return 0;
	    break;
	case WP_LAS_GUN:
	    if(g_bot_las.integer == 0)
		return 0;
	    break;
	case WP_MASS_DRIVER:
	    if(g_bot_mass.integer == 0)
		return 0;
	    break;
	case WP_CHAINGUN:
	    if(g_bot_chain.integer == 0)
		return 0;
	    break;
	case WP_PULSE_RIFLE:
	    if(g_bot_pulse.integer == 0)
		return 0;
	    break;
	case WP_FLAMER:
	    if(g_bot_flamer.integer == 0)
		return 0;
	    break;
	case WP_LUCIFER_CANNON:
	    if(g_bot_luci.integer == 0)
		return 0;
	    break;
	default: break;
    }
	    

    //add to inventory
    BG_AddWeaponToInventory( weapon, ent->client->ps.stats );
    BG_FindAmmoForWeapon( weapon, &maxAmmo, &maxClips );

    BG_PackAmmoArray( weapon, ent->client->ps.ammo, ent->client->ps.powerups,
                      maxAmmo, maxClips );

    G_ForceWeaponChange( ent, weapon );

    //set build delay/pounce etc to 0
    ent->client->ps.stats[ STAT_MISC ] = 0;

    //subtract from funds
    G_AddCreditToClient( ent->client, -(short)BG_FindPriceForWeapon( weapon ), qfalse );


    return 1;

}

int G_BotEvolve( gentity_t *ent, char *classname)
{
    int clientNum;
    int i;
    vec3_t infestOrigin;
    pClass_t currentClass = ent->client->pers.classSelection;
    pClass_t newClass;
    int numLevels;
    int entityList[ MAX_GENTITIES ];
    vec3_t range = { AS_OVER_RT3, AS_OVER_RT3, AS_OVER_RT3 };
    vec3_t mins, maxs;
    int num;
    gentity_t *other;


    if( ent->client->ps.stats[ STAT_HEALTH ] <= 0 )
        return 0;

    ent->client->pers.cmd.upmove = 0;

    clientNum = ent->client - level.clients;

    newClass = BG_FindClassNumForName( classname );

    //if we are not currently spectating, we are attempting evolution
    if( ent->client->pers.classSelection != PCL_NONE )
    {
        if( ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) ||
            ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) )
            return 0;

        //check there are no humans nearby
        VectorAdd( ent->client->ps.origin, range, maxs );
        VectorSubtract( ent->client->ps.origin, range, mins );

        num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
        for( i = 0; i < num; i++ )
        {
            other = &g_entities[ entityList[ i ] ];

            if( ( other->client && other->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ||
                ( other->s.eType == ET_BUILDABLE && other->biteam == BIT_HUMANS ) )
                return 0;
        }

        if( !level.overmindPresent )
            return 0;

        numLevels = BG_ClassCanEvolveFromTo( currentClass,
                                             newClass,
                                             (short)ent->client->ps.persistant[ PERS_CREDIT ], 0 );

        if( G_RoomForClassChange( ent, newClass, infestOrigin ) )
        {
            //...check we can evolve to that class
            if( numLevels >= 0 &&
                BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
                BG_ClassIsAllowed( newClass ) )
            {

                ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_HEALTH ] /
                                                         (float)BG_FindHealthForClass( currentClass );

                if( ent->client->pers.evolveHealthFraction < 0.0f )
                    ent->client->pers.evolveHealthFraction = 0.0f;
                else if( ent->client->pers.evolveHealthFraction > 1.0f )
                    ent->client->pers.evolveHealthFraction = 1.0f;

                //remove credit
                G_AddCreditToClient( ent->client, -(short)numLevels, qtrue );
                ent->client->pers.classSelection = newClass;
                ClientUserinfoChanged( clientNum );
                VectorCopy( infestOrigin, ent->s.pos.trBase );
                ClientSpawn( ent, ent, ent->s.pos.trBase, ent->s.apos.trBase );

                //trap_SendServerCommand( -1, va( "print \"evolved to %s\n\"", classname) );

                return 1;
            }
            else
                //trap_SendServerCommand( -1, va( "print \"Not enough evos to evolve to %s\n\"", classname) );
                return 0;
        }
        else
            return 0;
    }
    return 0;
}
void G_BotBuyAI( gentity_t *self )
{
    int i;
    // if bot buying is enabled
    if(g_bot_buy.integer > 0)
        // armoury in range
        if(G_BuildableRange( self->client->ps.origin, 100, BA_H_ARMOURY) && self->client->ps.weapon != WP_HBUILD) {

            if((self->client->time10000 % 2000) == 0 && (short)self->client->ps.persistant[ PERS_CREDIT ] > 0) {

                // sell current weapon
                for( i = WP_NONE + 1; i < WP_NUM_WEAPONS; i++ )
                {
                    if( BG_InventoryContainsWeapon( i, self->client->ps.stats ) &&
                        BG_FindPurchasableForWeapon( i ) )
                    {
                        BG_RemoveWeaponFromInventory( i, self->client->ps.stats );

                        //add to funds
                        G_AddCreditToClient( self->client, (short)BG_FindPriceForWeapon( i ), qfalse );
                    }

                    //if we have this weapon selected, force a new selection
                    if( i == self->client->ps.weapon )
                        G_ForceWeaponChange( self, WP_NONE );
                }


                // buy the stuff the friend has
                if(self->botFriend) {
                    if( BG_InventoryContainsUpgrade( UP_JETPACK, self->botFriend->client->ps.stats ))
                        G_BotBuyUpgrade( self, UP_JETPACK );

                    else if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, self->botFriend->client->ps.stats ))
                        G_BotBuyUpgrade( self, UP_BATTLESUIT );

                    else if( BG_InventoryContainsUpgrade( UP_LIGHTARMOUR, self->botFriend->client->ps.stats ) && random() <= 0.2)
                        G_BotBuyUpgrade( self, UP_LIGHTARMOUR);

                    else if( BG_InventoryContainsUpgrade( UP_HELMET, self->botFriend->client->ps.stats ))
                        G_BotBuyUpgrade( self, UP_HELMET);

                }
                G_BotBuyUpgrade( self, UP_HELMET);
                G_BotBuyUpgrade( self, UP_LIGHTARMOUR);

                // buy most expensive first, then one cheaper, etc, dirty but working way
                if( !G_BotBuy( self, WP_LUCIFER_CANNON ) )
                    if( !G_BotBuy( self, WP_FLAMER ) )
                        if( !G_BotBuy( self, WP_PULSE_RIFLE ) )
                            if( !G_BotBuy( self, WP_CHAINGUN ) )
                                if( !G_BotBuy( self, WP_MASS_DRIVER ) )
                                    if( !G_BotBuy( self, WP_LAS_GUN ) )
                                        if( !G_BotBuy( self, WP_SHOTGUN ) )
					    if( !G_BotBuy( self, WP_PAIN_SAW ) )
						G_BotBuy( self, WP_MACHINEGUN );
            }

            
	    if( BG_FindUsesEnergyForWeapon( self->client->ps.weapon )) {
		G_BotBuyUpgrade( self, UP_BATTPACK );
	    }else {
		G_BotBuyUpgrade( self, UP_AMMO );
	    }
        }
     // end humans
}

void G_BotEvolveAI ( gentity_t *self )
{
    //if bot evolution is enabled
    if(g_bot_evolve.integer > 0)
        if(self->client->pers.teamSelection == PTE_ALIENS) {

            if((self->client->time10000 % 2000) == 0)
                // check if evo's > 0
                if( (short)self->client->ps.persistant[ PERS_CREDIT ] > 0) {
                    //trap_SendServerCommand( -1, va( "print \"trying to evolve\n\"") );

                    // very not-clean code, but hea it works
                    int res;
                    if(!G_BotEvolve(self, "level4"))
                        if(!G_BotEvolve(self, "level3upg")) {
                            res = (random()>0.5) ? G_BotEvolve(self, "level3") : G_BotEvolve(self, "level2upg");
                            if(!res) {
                                res = (random()>0.5) ? G_BotEvolve(self, "level2") : G_BotEvolve(self, "level1upg");
                                if(!res)
                                    if(!G_BotEvolve(self, "level1"))
                                        G_BotEvolve(self, "level0");
                            }
                        }

                }

        }       // aliens
}
void G_BotAttack( gentity_t *self, qboolean move ) {

 if(!self->botEnemy) {

        // no enemy
       /* if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
            self->client->pers.cmd.upmove = -1;*/
 } else {
        // enemy!
        self->client->ps.pm_flags &= ~PMF_CROUCH_HELD;
        // gesture
        if(random() <= 0.1) self->client->pers.cmd.buttons |= BUTTON_GESTURE;


        botAimAtTarget(self, self->botEnemy);

        // enable wallwalk
        if( BG_ClassHasAbility( self->client->pers.classSelection, SCA_WALLCLIMBER ) )
            self->client->pers.cmd.upmove = -1;
         // jetpack
        if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && BG_UpgradeIsActive(BG_FindUpgradeNumForName((char *)"jetpack"), self->botFriend->client->ps.stats))
            BG_ActivateUpgrade( BG_FindUpgradeNumForName((char *)"jetpack"), self->client->ps.stats );
        else
            BG_DeactivateUpgrade( BG_FindUpgradeNumForName((char *)"jetpack"), self->client->ps.stats );

        botShootIfTargetInRange(self,self->botEnemy);
        if( move )
            G_BotMove( self );
    }
}
void G_BotMove(gentity_t *self)
{
    //prevent human bots from moving toward target while attacking buildables
    //TODO: Refacter this to be much cleaner and less of a hack
    if( self->botEnemy->s.eType != ET_BUILDABLE || 
	self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS || 
	!botTargetInLOS(self,self->botEnemy) ||
	// !botTargetInRange(self, (self->botEnemy) ? self->botEnemy : self->botTarget)){
	(self->client->ps.weapon == WP_FLAMER && botGetDistanceBetweenPlayer(self, self->botEnemy) > FLAMER_LIFETIME * FLAMER_SPEED / 1000) ||
	(self->client->ps.weapon == WP_PAIN_SAW && botGetDistanceBetweenPlayer( self, self->botEnemy) > PAINSAW_RANGE)) {
    
	//dont go too far if in defend mode
	if( Distance( self->s.pos.trBase, self->botDefensePoint ) < MGTURRET_RANGE * 3 ||
	    self->botCommand != BOT_DEFENSIVE)
	self->client->pers.cmd.forwardmove = 127;

       if( !self->isTargetingPath ) {
	self->client->pers.cmd.rightmove = -100;
	if(self->client->time1000 >= 500 && random() < 0.7)
	    self->client->pers.cmd.rightmove = 100;
       }
	
	self->client->ps.stats[ STAT_STAMINA ] = MAX_STAMINA;
	
	if( botPathIsBlocked( self ) ) {
	    self->client->pers.cmd.upmove = 127;
	}
	
	//need to periodically reset upmove to 0 for jump to work
	if( self->client->time10000 % 1000)
	    self->client->pers.cmd.upmove = 0;
	
	//use paths to get to target
            if(self->botEnemy || self->botTarget && self->client->time10000 % 5000 && !self->isTargetingPath) {
                findPathToTarget(self);
                self->timeFoundPath = level.time;
                self->targetPath = self->pathSize;
            }
            
            if( self->botEnemy || self->botTarget && self->pathSize >= 0 && self->targetPath != -1) {
                botAimAtPath(self);
                self->isTargetingPath = qtrue;
                if( distanceToTargetNode( self) < 80 && level.time > self->timeFoundPath + 1000) {
                    self->targetPath = self->pathToTarget[self->targetPath];
                    self->timeFoundPath = level.time;
                }
            } else 
                self->isTargetingPath = qfalse;
            /*if(self->botEnemy)
                temp = self->botEnemy;
            else
                temp = self->botTarget;
            findnewpath(temp);*/
            /*if(distanceToTargetNode(self) < 70 && prev[self->targetPath] != -1) {
                self->lastpathid = self->targetPath;
            self->targetPath = prev[self->targetPath];
            }*/
            
            
                
                
        //botGotoTarget( self);
	
	/*if(self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && 
            Distance( self->s.pos.trBase, self->botEnemy->s.pos.trBase ) < 300 && 
            self->client->ps.weapon != WP_PAIN_SAW && 
            self->client->ps.weapon != WP_FLAMER) {
            
                self->client->pers.cmd.forwardmove = -100;
                
            }*/
	/*if( self->botEnemy && self->client->pers.teamSelection == PTE_HUMANS) {
            
	    //backup if we can hit him from here and he can hit us from here
	    //If we cant hit him we will move forward regardless of if he can hit us
	    // Good for short range weapons like flamer and psaw
	    if(botTargetInRange(self->botEnemy, self) && botTargetInRange(self, self->botEnemy))
		self->client->pers.cmd.forwardmove = -127;
            
            //if we can hit him and he cant hit us dont move closer
            if(!botTargetInRange(self->botEnemy, self) && botTargetInRange( self, self->botEnemy))
                self->client->pers.cmd.forwardmove = 0;
             //if we cant hit him move closer
            if(!botTargetInRange(self, self->botEnemy))
                self->client->pers.cmd.forwardmove = 127;
	    //we are in his face
                */
	    /*if( distance < 50) {
		
		
		if(self->lastDodgeTime + 2000 < level.time) {
		    strafeDirection = random();
		    self->lastDodgeTime = level.time;
		}
		
		//go around him
		if( strafeDirection > 0.5) {
		    self->client->pers.cmd.rightmove = -100;
		} else {
		    self->client->pers.cmd.rightmove = 100;
		}
	    }*/
	}
    }
//TODO: Refacter a bunch of this, way too much code duplication going on here + this function is HUGE. - Fuma
void G_BotThink( gentity_t *self )
{
    int distance = 0;
    int clicksToStopChase = 30;     //5 seconds
    int tooCloseDistance = 100;     // about 1/3 of turret range
    int tempEntityIndex = -1;
    int tempEntityIndex2 = -1;
    
    qboolean followFriend = qfalse;
    
    self->client->pers.cmd.buttons = 0;
    self->client->pers.cmd.forwardmove = 0;
    self->client->pers.cmd.rightmove = 0;

    // reset botEnemy if enemy is dead
    if(self->botEnemy && self->botEnemy->health <= 0)
        self->botEnemy = NULL;

    // if friend dies, reset status to auto
    if(self->botFriend && self->botFriend->health <= 0) {
        self->botCommand = BOT_AUTO;
        self->botFriend = NULL;
    }

    // if health < 30, use medkit
    if(self->health <= 30)
        BG_ActivateUpgrade( UP_MEDKIT, self->client->ps.stats );



    if(self->client->pers.teamSelection == PTE_HUMANS) {
        //if using ckit change to blaster if not in repair or auto mode
        if(self->client->ps.weapon == WP_HBUILD && self->botCommand != BOT_REPAIR && self->botCommand != BOT_AUTO)
            G_ForceWeaponChange( self, WP_BLASTER );
        // if weapon is empty switch to blaster
        if(BG_WeaponIsEmpty(self->client->ps.weapon, self->client->ps.stats, self->client->ps.ammo, self->client->ps.powerups))
            G_ForceWeaponChange( self, WP_BLASTER );
    }

    //every 5 seconds, look for a new, closer, enemy
    if(self->client->time10000 % 5000) {
	tempEntityIndex = botFindClosestEnemy( self, qfalse );
	if( tempEntityIndex != -1 )
	    self->botEnemy = &g_entities[tempEntityIndex];
    }
    
    //prevent TK destruction with luci
    if( self->client->ps.weapon == WP_LUCIFER_CANNON && !self->botEnemy && self->isFireing)
    {
        G_ForceWeaponChange( self, WP_BLASTER );
        G_ForceWeaponChange( self, WP_LUCIFER_CANNON );
        self->isFireing = qfalse;
    }
    G_BotBuyAI( self );
    G_BotEvolveAI( self );

    //bot path stuff
    if( !self->botEnemy && 1 < 0)
        pathfinding(self);
    if(!self->botEnemy && !self->botFriend && self->state == TARGETPATH && 1 < 0)
        {
                botAimAtPath(self);
                G_BotMove( self );
    if(self->lastpathid >= 0)
                {
                        switch(level.paths[self->lastpathid].action)
                        {
                                case BOT_JUMP:  
                                                
                                                        if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && 
                                                                self->client->ps.stats[ STAT_STAMINA ] < 0 )
                                                        {break;}
                                                        if( !BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) )
                                                     
                                                        self->client->pers.cmd.upmove = 20;
                                            

                                                break;
                                case BOT_WALLCLIMB: if( BG_ClassHasAbility( self->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER ) ) {
                                                        self->client->pers.cmd.upmove = -1;
                                                        }
                                                        break;
                                case BOT_KNEEL: if(self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS)
                                                {
                                                        self->client->pers.cmd.upmove = -1;
                                                }
                                                break;
                                case BOT_POUNCE:if(self->client->pers.classSelection == PCL_ALIEN_LEVEL3 && 
                                                        self->client->ps.stats[ STAT_MISC ] < LEVEL3_POUNCE_SPEED)
                                                        self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
                                                else if(self->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG && 
                                                        self->client->ps.stats[ STAT_MISC ] < LEVEL3_POUNCE_UPG_SPEED)
                                                        self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
                                                break;
                                default: break;
                        }
                        if(level.time - self->timeFoundPath > level.paths[self->lastpathid].timeout)
                        {
                                self->state = FINDNEWPATH;
                                self->timeFoundPath = level.time;
                        }
                }
                else if( level.time - self->timeFoundPath > 10000 )
                {
                        self->state = FINDNEWPATH;
                        self->timeFoundPath = level.time;
                }
                if(distanceToTargetNode(self) < 70)
                {
                        self->state = FINDNEXTPATH;
                        self->timeFoundPath = level.time;
                }

        }
    // what mode are we in?
    switch(self->botCommand) {

    case BOT_REGULAR:

        // if there is enemy around, rush them and attack.
        if(self->botEnemy) {
            // we already have an enemy. See if still in LOS.
            if(!botTargetInLOS(self,self->botEnemy)) {
                // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                if(self->botEnemyLastSeen > clicksToStopChase) {
                    // forget him!
                    self->botEnemy = NULL;
                    self->botEnemyLastSeen = 0;
                } else
                    //chase him
                    self->botEnemyLastSeen++;
            } else
                // we see him!
                self->botEnemyLastSeen = 0;
        }
        if(!self->botEnemy) {
            // try to find closest enemy
            tempEntityIndex = botFindClosestEnemy(self, qfalse);
            if(tempEntityIndex >= 0)
                self->botEnemy = &g_entities[tempEntityIndex];
        }
        G_BotAttack( self, qtrue);


        break;


    case BOT_IDLE:
        // just stand there and look ugly.
        if( random() <= 0.4 )
            self->client->ps.pm_flags |= PMF_CROUCH_HELD;
        break;

    case BOT_ATTACK:
        // .. not sure ..
        break;

    case BOT_STAND_GROUND:
        // stand ground but attack enemies if you can reach.
        if(self->botEnemy)
            // we already have an enemy. See if still in LOS.
            if(!botTargetInLOS(self,self->botEnemy))
                //we are not in LOS
                self->botEnemy = NULL;
        if(!self->botEnemy) {
            // try to find closest enemy
            tempEntityIndex = botFindClosestEnemy(self, qfalse);
            if(tempEntityIndex >= 0)
                self->botEnemy = &g_entities[tempEntityIndex];
        }
        G_BotAttack( self, qfalse );
        break;

    case BOT_DEFENSIVE:
        // if there is an enemy around, rush them but not too far from where you are standing when given this command
        // if there is enemy around, rush them and attack.
        if(self->botEnemy) {
            // we already have an enemy. See if still in LOS.
            if(!botTargetInLOS(self,self->botEnemy)) {
                // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                if(self->botEnemyLastSeen > clicksToStopChase) {
                    // forget him!
                    self->botEnemy = NULL;
                    self->botEnemyLastSeen = 0;
                } else
                    //chase him
                    self->botEnemyLastSeen++;
            } else
                // we see him!
                self->botEnemyLastSeen = 0;
        }
        if(!self->botEnemy) {
            // try to find closest enemy
            tempEntityIndex = botFindClosestEnemy(self, qfalse);
            if(tempEntityIndex >= 0)
                self->botEnemy = &g_entities[tempEntityIndex];
        }
        G_BotAttack( self, qtrue);
        break;

    case BOT_FOLLOW_FRIEND_PROTECT:
        // run towards friend, attack enemy
        break;

    case BOT_FOLLOW_FRIEND_ATTACK:
        // run with friend until enemy spotted, then rush enemy
        if(self->botEnemy) {
            // we already have an enemy. See if still in LOS.
            if(!botTargetInLOS(self,self->botEnemy)) {
                // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                if(self->botEnemyLastSeen > clicksToStopChase) {
                    // forget him!
                    self->botEnemy = NULL;
                    self->botEnemyLastSeen = 0;
                } else
                    //chase him
                    self->botEnemyLastSeen++;
            } else
                // we see him!
                self->botEnemyLastSeen = 0;

            //if we are chasing enemy, reset counter for friend LOS .. if its true
            if(self->botEnemy) {
                if(botTargetInLOS(self,self->botFriend))
                    self->botFriendLastSeen = 0;
                else
                    self->botFriendLastSeen++;
            }
        }

        if(!self->botEnemy) {
            // try to find closest enemy
            tempEntityIndex = botFindClosestEnemy(self, qfalse);
            if(tempEntityIndex >= 0)
                self->botEnemy = &g_entities[tempEntityIndex];
        }

        if(!self->botEnemy) {
            // no enemy
            if(self->botFriend) {
                // see if our friend is in LOS
                if(botTargetInLOS(self,self->botFriend)) {
                    // go to him!
                    followFriend = qtrue;
                    self->botFriendLastSeen = 0;
                } else {
                    // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                    if(self->botFriendLastSeen > clicksToStopChase)
                        // forget him!
                        followFriend = qfalse;
                    else {
                        self->botFriendLastSeen++;
                        followFriend = qtrue;
                    }
                }

                if(followFriend) {
                    distance = botGetDistanceBetweenPlayer(self, self->botFriend);
                    botAimAtTarget(self, self->botFriend);

                    // enable wallwalk
                    if( BG_ClassHasAbility( self->client->pers.classSelection, SCA_WALLCLIMBER ) )
                        self->client->pers.cmd.upmove = -1;
                                                 // jetpack
                    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && BG_UpgradeIsActive(BG_FindUpgradeNumForName((char *)"jetpack"), self->botFriend->client->ps.stats))
                        BG_ActivateUpgrade( BG_FindUpgradeNumForName((char*)"jetpack"), self->client->ps.stats );
                    else
                        BG_DeactivateUpgrade( BG_FindUpgradeNumForName((char *)"jetpack"), self->client->ps.stats );

                    //botShootIfTargetInRange(self,self->botEnemy);
                    if(distance>tooCloseDistance)
                        G_BotMove( self );
                }
            }
        } else {
            // enemy!
            self->client->ps.pm_flags &= ~PMF_CROUCH_HELD;
            if( random() < 0.1 ) self->client->pers.cmd.buttons |= BUTTON_GESTURE;
            distance = botGetDistanceBetweenPlayer(self, self->botEnemy);
            botAimAtTarget(self, self->botEnemy);

            // enable wallwalk
            if( BG_ClassHasAbility( self->client->pers.classSelection, SCA_WALLCLIMBER ) )
                self->client->pers.cmd.upmove = -1;
                                 // jetpack
            if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && BG_UpgradeIsActive(BG_FindUpgradeNumForName((char *)"jetpack"), self->botFriend->client->ps.stats))
                BG_ActivateUpgrade( BG_FindUpgradeNumForName((char*)"jetpack"), self->client->ps.stats );
            else
                BG_DeactivateUpgrade( BG_FindUpgradeNumForName((char *)"jetpack"), self->client->ps.stats );

            botShootIfTargetInRange(self,self->botEnemy);
            G_BotMove( self );
        }

        break;

    case BOT_FOLLOW_FRIEND_IDLE:
        // run with friend and stick with him no matter what. no attack mode.
        if(self->botFriend) {
            // see if our friend is in LOS
            if(botTargetInLOS(self,self->botFriend)) {
                // go to him!
                followFriend = qtrue;
                self->botFriendLastSeen = 0;
            } else {
                // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                if(self->botFriendLastSeen > clicksToStopChase)
                    // forget him!
                    followFriend = qfalse;
                else {
                    //chase him
                    self->botFriendLastSeen++;
                    followFriend = qtrue;
                }
            }

            if(followFriend) {
                distance = botGetDistanceBetweenPlayer(self, self->botFriend);
                botAimAtTarget(self, self->botFriend);

                // enable wallwalk
                if( BG_ClassHasAbility( self->client->pers.classSelection, SCA_WALLCLIMBER ) )
                    self->client->pers.cmd.upmove = -1;
                                         // jetpack
                if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && BG_UpgradeIsActive(BG_FindUpgradeNumForName((char *)"jetpack"), self->botFriend->client->ps.stats))
                    BG_ActivateUpgrade( BG_FindUpgradeNumForName((char*)"jetpack"), self->client->ps.stats );
                else
                    BG_DeactivateUpgrade( BG_FindUpgradeNumForName((char *)"jetpack"), self->client->ps.stats );

                //botShootIfTargetInRange(self,self->botFriend);
                if(distance>tooCloseDistance)
                    G_BotMove( self );
            }
        }

        break;

    case BOT_TEAM_KILLER:
        // attack enemies, then teammates!
        if(self->botEnemy) {
            // we already have an enemy. See if still in LOS.
            if(!botTargetInLOS(self,self->botEnemy)) {
                // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                if(self->botEnemyLastSeen > clicksToStopChase) {
                    // forget him!
                    self->botEnemy = NULL;
                    self->botEnemyLastSeen = 0;
                } else
                    //chase him
                    self->botEnemyLastSeen++;
            } else
                // we see him!
                self->botEnemyLastSeen = 0;
        }
        if(!self->botEnemy) {
            // try to find closest enemy
            tempEntityIndex = botFindClosestEnemy(self, qtrue);
            if(tempEntityIndex >= 0)
                self->botEnemy = &g_entities[tempEntityIndex];
        }
        G_BotAttack( self, qtrue );
        break;

    case BOT_REPAIR:

        //check if we have ckit, if not, revert to regular
        if (!BG_InventoryContainsWeapon( WP_HBUILD, self->client->ps.stats)) {
            trap_SendServerCommand( -1, va( "print \"Sorry boss, but I dont have ckit, reverting to auto...\n\"") );
            self->botCommand = BOT_AUTO;
        } else {
            // Find the entity to repair and turn in that direction
            tempEntityIndex = botFindDamagedFriendlyStructure(self);
            botAimAtTarget(self, &g_entities[tempEntityIndex]);

            if( botGetDistanceBetweenPlayer( self, &g_entities[tempEntityIndex] ) <
                100 )
                // If we are within the distance of the structure, than we
                // start directly with repairing
                self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
            else
                // Otherwise, we move in that direction, generally
                G_BotMove( self );
        }
        break;
    case BOT_AUTO:
        // Find if any entities need repairing
        tempEntityIndex = botFindDamagedFriendlyStructure(self);
        tempEntityIndex2 = botFindMedistat(self);
        //if an enemy isnt in range and bot is on human team
        if (!self->botEnemy && self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS) {
            //TODO: INSERT GO TO ARMORY AND BUY CKIT CODE HERE

            //if we have ckit and stuff is damaged
            if (BG_InventoryContainsWeapon( WP_HBUILD, self->client->ps.stats) && tempEntityIndex != -1) {
		
		self->botTarget = &g_entities[tempEntityIndex];

                //change to ckit if we havent already
                if (self->client->ps.weapon != WP_HBUILD)
                    G_ForceWeaponChange( self, WP_HBUILD );
                
                if(!self->isTargetingPath)
                botAimAtTarget(self, self->botTarget);

                if( botGetDistanceBetweenPlayer( self, self->botTarget ) <
                    100 && !botPathIsBlocked(self))
                    // If we are within the distance of the structure, than we
                    // start directly with repairing
                    self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
                else
                    // Otherwise, we move in that direction, generally

                    G_BotMove( self );


                         //nothing to repair do find medistat AI
            } else if ( tempEntityIndex2 != -1 && (self->health < 100 || !BG_InventoryContainsUpgrade(UP_MEDKIT, self->client->ps.stats)) ) {
                self->botTarget = &g_entities[tempEntityIndex2];
		//aim at the medistat
                if(!self->isTargetingPath)
                botAimAtTarget(self, self->botTarget);
                if( botGetDistanceBetweenPlayer( self, self->botTarget ) > 50) 
                G_BotMove( self );

            } else           //switch to blaster (hack to get them to buy something at arm)
self->botTarget = NULL;
            if (self->client->ps.weapon == WP_HBUILD)
                G_ForceWeaponChange( self, WP_BLASTER);
            //check if any enemies
            tempEntityIndex = botFindClosestEnemy(self, qfalse);
            if(tempEntityIndex >= 0) {
                self->botEnemy = &g_entities[tempEntityIndex];
		self->botTarget = NULL;
	    }

            //enemy appears or we are on aliens do regular AI
        } else {

            if (self->client->ps.weapon == WP_HBUILD)
                G_ForceWeaponChange( self, WP_BLASTER);
            // if there is enemy around, rush them and attack.
            if(self->botEnemy) {
                // we already have an enemy. See if still in LOS.
                if(!botTargetInLOS(self,self->botEnemy)) {
                    // if it's been over clicksToStopChase clicks since we last seen him in LOS then do nothing, else follow him!
                    if(self->botEnemyLastSeen > clicksToStopChase) {
                        // forget him!
                        self->botEnemy = NULL;
                        self->botEnemyLastSeen = 0;
                    } else
                        //chase him
                        self->botEnemyLastSeen++;
                } else
                    // we see him!
                    self->botEnemyLastSeen = 0;
            }
            if(!self->botEnemy) {
                // try to find closest enemy
                tempEntityIndex = botFindClosestEnemy(self, qfalse);
                if(tempEntityIndex >= 0)
                    self->botEnemy = &g_entities[tempEntityIndex];
            }
            G_BotAttack( self, qtrue );
        }
        break;

    default:
        // dunno.
        break;
    }
}

void G_BotSpectatorThink( gentity_t *self ) {
    if( self->client->ps.pm_flags & PMF_QUEUED)
        //we're queued to spawn, all good
        return;

    if( self->client->sess.sessionTeam == TEAM_SPECTATOR ) {
        int teamnum = self->client->pers.teamSelection;
        int clientNum = self->client->ps.clientNum;

        if( teamnum == PTE_HUMANS ) {
            self->client->pers.classSelection = PCL_HUMAN;
            self->client->pers.classSelection = PCL_HUMAN;

            self->client->pers.humanItemSelection = self->spawnItem;


            G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );
        } else if( teamnum == PTE_ALIENS) {
            self->client->pers.classSelection = PCL_ALIEN_LEVEL0;
            self->client->pers.classSelection = PCL_ALIEN_LEVEL0;
            G_PushSpawnQueue( &level.alienSpawnQueue, clientNum );
        }
    }
}

/*
 * Called when we are in intermission.
 * Just flag that we are ready to proceed.
 */
void G_BotIntermissionThink( gclient_t *client )
{
    client->readyToExit = qtrue;
}

qboolean botAimAtTarget( gentity_t *self, gentity_t *target ) {
    int Ax,Ay,Az,Bx,By,Bz = 0;
    vec3_t dirToTarget, angleToTarget;
    vec3_t top = { 0, 0, 0};
    vec3_t  forward, right, up;
    vec3_t  muzzle,delta;
    vec3_t highPoint;
    float deltangle,deltangle2,diffangle,diffangle2;
    AngleVectors( self->client->ps.viewangles, forward, right, up );
    CalcMuzzlePoint( self, forward, right, up, muzzle );
    if(self->client->pers.classSelection == PCL_ALIEN_LEVEL3 || 
        self->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG)
    {
        Ax = target->s.pos.trBase[0];
        Ay = target->s.pos.trBase[1];
        Az = target->s.pos.trBase[2];
        Bx = self->s.pos.trBase[0];
        By = self->s.pos.trBase[1];
        Bz = self->s.pos.trBase[2];
        if(self->client->pers.classSelection == PCL_ALIEN_LEVEL3)
        {top[2] = (int)(sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz)) / 3);}
        else
        {top[2] = (int)(sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz)) / 5);}
    }
    VectorCopy( target->s.pos.trBase, highPoint );
    highPoint[2] += target->r.maxs[2] * 0.85;
    VectorAdd( highPoint, top, top);
    VectorSubtract( top, muzzle, dirToTarget );
    VectorNormalize( dirToTarget );
    vectoangles( dirToTarget, angleToTarget );
    deltangle = SHORT2ANGLE(self->client->ps.delta_angles[0]);
    deltangle2 = SHORT2ANGLE(self->client->ps.delta_angles[1]);
    diffangle = AngleSubtract(angleToTarget[0],deltangle);
    diffangle2 = AngleSubtract(angleToTarget[1],deltangle2);
    if(diffangle > self->botSkillLevel)
    {
        delta[0] = deltangle + self->botSkillLevel;
    }
    else if(diffangle < -self->botSkillLevel)
    {
        delta[0] = deltangle - self->botSkillLevel;
    }
    else
    {
        delta[0] = angleToTarget[0];
    }
    if(diffangle2 > self->botSkillLevel)
    {
        delta[1] = deltangle2 + self->botSkillLevel;
    }
    else if(diffangle2 < -self->botSkillLevel)
    {
        delta[1] = deltangle2 - self->botSkillLevel;
    }
    else
    {
        delta[1] = angleToTarget[1];
    }
    self->client->ps.delta_angles[0] = ANGLE2SHORT(delta[0]);
    self->client->ps.delta_angles[1] = ANGLE2SHORT(delta[1]);
    
    if(angleToTarget[0] > -350 && angleToTarget[0] < -180 && target->s.eType == ET_BUILDABLE) {
        if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && self->client->ps.weapon == WP_PAIN_SAW)
            // down
        self->client->pers.cmd.upmove = -1;
    }
    if(angleToTarget[0] < -6.0 && angleToTarget[0] > -180 && 
        (self->client->pers.classSelection == PCL_ALIEN_LEVEL2 ||
        self->client->pers.classSelection == PCL_ALIEN_LEVEL2_UPG ||
        self->client->ps.stats[STAT_PTEAM] == PTE_HUMANS) && target->s.eType != ET_BUILDABLE
    )
        // up
    self->client->pers.cmd.upmove = 127;
    
    return qtrue;
}
qboolean botTargetInLOS( gentity_t *self, gentity_t *target ) {
    trace_t trace;
    gentity_t *traceEnt;
    vec3_t  forward, right, up;
    vec3_t  muzzle;
    AngleVectors( self->client->ps.viewangles, forward, right, up );
    CalcMuzzlePoint( self, forward, right, up, muzzle );
    //int myGunRange;
    //myGunRange = MGTURRET_RANGE * 3;

    if( !self || !target )
        return qfalse;

    if( !self->client || !target->client )
        if( target->s.eType != ET_BUILDABLE )
            return qfalse;

    if( target->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
        return qfalse;

    if( target->health <= 0 )
        return qfalse;
    
    
    
    //aliens need a wide trace, otherwise they will team kill
    /**/


	
    //draw line between us and the target and see what we hit
    trap_Trace( &trace, muzzle, NULL, NULL, target->s.pos.trBase, self->s.number, MASK_SHOT );
    traceEnt = &g_entities[ trace.entityNum ];
    //}
    // check that we hit a human and not an object
    //if( !traceEnt->client )
    //	return qfalse;

    //check our target is in LOS
    if(traceEnt != target)
        return qfalse;

    return qtrue;
}

/*
 * Find the entity index of a friendly building which is in range of the bot.
 * Returns -1 if no entity is in range.
 * @TODO: refactor generic code out from botFindClosestEnemy
 */
int botFindDamagedFriendlyStructure( gentity_t *self )
{
    // The range of our scanning field.
    int vectorRange = MGTURRET_RANGE * 3;
    // vectorRange converted to a vector
    vec3_t range;
    // Lower bound vector
    vec3_t mins;
    // Upper bound vector
    vec3_t maxs;
    // Indexing field
    int i;
    // Entities located in scanning field
    int total_entities;
    // Array which contains the located entities
    int entityList[ MAX_GENTITIES ];
    int min_distance = MGTURRET_RANGE * 3;
    int nearest_dmged_building = -1;
    // Temporary entitiy
    gentity_t *target;
    // Temporary buildable
    buildable_t inspectedBuilding;

    VectorSet( range, vectorRange, vectorRange, vectorRange );
    VectorAdd( self->client->ps.origin, range, maxs );
    VectorSubtract( self->client->ps.origin, range, mins );

    // Fetch all entities in the bounding box and iterate over them
    // to locate the structures that belong to the team of the bot and that
    // are not at full health.
    total_entities = trap_EntitiesInBox(mins, maxs, entityList, MAX_GENTITIES);
    for( i = 0; i < total_entities; ++i )
    {
        target = &g_entities[ entityList[ i ] ];
        inspectedBuilding = BG_FindBuildNumForEntityName( target->classname );
        if(target->s.eType == ET_BUILDABLE &&
           target->biteam == self->client->ps.stats[ STAT_PTEAM ] &&
           target->health !=  BG_FindHealthForBuildable( inspectedBuilding ) ) {
            if( botGetDistanceBetweenPlayer( self, target ) < min_distance ) {
                min_distance = botGetDistanceBetweenPlayer( self, target );
                nearest_dmged_building = entityList[ i ];
            }
        }
    }
    return nearest_dmged_building;
}
int botFindMedistat(gentity_t *self) {
    // The range of our scanning field.
    int vectorRange = MGTURRET_RANGE * 100;
    // vectorRange converted to a vector
    vec3_t range;
    // Lower bound vector
    vec3_t mins;
    // Upper bound vector
    vec3_t maxs;
    // Indexing field
    int total_entities;
    int entityList[ MAX_GENTITIES ];
    int i;
    int min_distance = MGTURRET_RANGE * 100;
    int closest_medi = -1;
    gentity_t *target;
    VectorSet( range, vectorRange, vectorRange, vectorRange );
    VectorAdd( self->client->ps.origin, range, maxs );
    VectorSubtract( self->client->ps.origin, range, mins );
    total_entities = trap_EntitiesInBox(mins, maxs, entityList, MAX_GENTITIES);
    for( i = 0; i < total_entities; ++i )
    {
        target = &g_entities[entityList[ i ] ];

        if( target->s.eType == ET_BUILDABLE && target->s.modelindex == BA_H_MEDISTAT && target->powered) {
            if( botGetDistanceBetweenPlayer( self, target ) < min_distance ) {
                min_distance = botGetDistanceBetweenPlayer( self, target );
                closest_medi = entityList[i];
            }
        }

    }
        return closest_medi;
}

int botFindClosestEnemy( gentity_t *self, qboolean includeTeam ) {
    // return enemy entity index, or -1
    int vectorRange = MGTURRET_RANGE * 3;
    int i;
    int total_entities;
    int entityList[ MAX_GENTITIES ];
    int minDistance = MGTURRET_RANGE * 3;
    int closestTarget = -1;
    vec3_t range;
    vec3_t mins, maxs;
    gentity_t *target;
    VectorSet( range, vectorRange, vectorRange, vectorRange );
    VectorAdd( self->client->ps.origin, range, maxs );
    VectorSubtract( self->client->ps.origin, range, mins );

    total_entities = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
    
    for( i = 0; i < total_entities; ++i )
    {
        target = &g_entities[entityList[ i ] ];

        //if entity is closer than previous stored one and the target is alive
	if( botGetDistanceBetweenPlayer( self, target ) < minDistance && target->health > 0) {
	    
	    //if we can see the entity OR we are on aliens (who dont care about LOS because they have radar)
	    if( /*self->client->ps.stats[STAT_PTEAM] == PTE_ALIENS ||*/ botTargetInLOS(self, target) ){
		
		//if the entity is a building and we can attack structures and we are not a dretch
		if(target->s.eType == ET_BUILDABLE && g_bot_attackStruct.integer && self->client->pers.classSelection != PCL_ALIEN_LEVEL0) {
		    
		    //if the building is not on our team (unless we can attack teamates)
		    if( target->biteam != self->client->ps.stats[STAT_PTEAM] || includeTeam ) {
			
			//store the new distance and the index of the entity
			minDistance = botGetDistanceBetweenPlayer( self, target );
			closestTarget = entityList[i];
		    }
		    //if the entity is a player and not us
		} else if( target->client && self != target) {
		    //if we are not on the same team (unless we can attack teamates)
		    if( target->client->ps.stats[STAT_PTEAM] != self->client->ps.stats[STAT_PTEAM] || includeTeam ) {
			
			//store the new distance and the index of the enemy
			minDistance = botGetDistanceBetweenPlayer( self, target );
			closestTarget = entityList[i];
		    }
		}
	    }
	}

    }
        return closestTarget;
    // check list for enemies
   /* for( i = 0; i < total_entities; i++ ) {
        target = &g_entities[ entityList[ i ] ];

        if( (target->s.eType == ET_BUILDABLE || target->client) && self != target ) {
            if( target->s.eType == ET_BUILDABLE) {
                if( target->biteam != self->client->ps.stats[ STAT_PTEAM ]  && g_bot_attackStruct.integer > 0) {
                    // aliens ignore if it's in LOS because they have radar
                    if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS)
                        return entityList[ i ];
                    else  if( botTargetInRange( self, target ) )
                        return entityList[ i ];

                }
            }
            else    if( target->client->ps.stats[ STAT_PTEAM ] != self->client->ps.stats[ STAT_PTEAM ] ) {
                // aliens ignore if it's in LOS because they have radar
                if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS)
                    return entityList[ i ];
                else  if( botTargetInRange( self, target ) )
                    return entityList[ i ];

            }
        }
    }

    if(includeTeam)
        // check list for enemies in team
        for( i = 0; i < total_entities; i++ ) {
            target = &g_entities[ entityList[ i ] ];

            if( target->client && self !=target && target->client->ps.stats[ STAT_PTEAM ] == self->client->ps.stats[ STAT_PTEAM ] ) {
                // aliens ignore if it's in LOS because they have radar
                if(self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS)
                    return entityList[ i ];
                else  if( botTargetInRange( self, target ) )
                    return entityList[ i ];

            }
        }
   

    return -1;*/
}

// really an int? what if it's too long?
int botGetDistanceBetweenPlayer( gentity_t *self, gentity_t *player ) {
    return Distance( self->s.pos.trBase, player->s.pos.trBase );
}
qboolean botPathIsBlocked( gentity_t *self ) {
    trace_t trace;
    gentity_t *traceEnt;
    gentity_t *target;
    vec3_t  forward, right, up;
    vec3_t end;
    if(self->botEnemy)
	target = self->botEnemy;
    else
	target = self->botTarget;
    AngleVectors( self->client->ps.viewangles, forward, right, up );
    VectorMA( self->s.pos.trBase, 100, forward, end );
    trap_Trace( &trace, self->s.pos.trBase, NULL, NULL, end, self->s.number, MASK_SHOT );
     traceEnt = &g_entities[ trace.entityNum ];
    /*for( i = 0; i < total_entities; ++i )
    {
        target = &g_entities[entityList[ i ] ];

        if( target->s.eType == ET_BUILDABLE && botGetDistanceBetweenPlayer( self, target) < 50 )

            if( target->s.modelindex != BA_H_MEDISTAT && target->s.modelindex != BA_A_BOOSTER && target->biteam == self->client->ps.stats[ STAT_PTEAM ])
                return qtrue;
    }*/
    //if we hit something other than our target and we did hit something
    if(trace.fraction < 1.0f && target->s.eType != ET_BUILDABLE)
	return qtrue;
    return qfalse;
}
qboolean botShootIfTargetInRange( gentity_t *self, gentity_t *target ) {
    if(botTargetInLOS(self,target)) {
        /*if( self->client->time1000  <= 200 &&  self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
            self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
        else {*/
	if( self->client->ps.stats[STAT_PTEAM] == PTE_ALIENS )
	{
                        if (self->client->pers.classSelection == PCL_ALIEN_BUILDER0)
                        {
                            self->client->pers.cmd.buttons |= BUTTON_GESTURE;
                        }
                        else if (self->client->pers.classSelection == PCL_ALIEN_BUILDER0_UPG)//adv granger
                        {
                            if (random() > 0.3)
                                self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
                            else
                                self->client->pers.cmd.buttons |= BUTTON_USE_HOLDABLE;
                        }
	                if (self->client->pers.classSelection == PCL_ALIEN_LEVEL1_UPG)//adv basilisk
			{
				if (random() > 0.5)
					self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
				else if(botTargetInRange( self, target ))
					self->client->pers.cmd.buttons |= BUTTON_ATTACK;
			}
			else if (self->client->pers.classSelection == PCL_ALIEN_LEVEL2_UPG)//adv marauder
			{
				if (Distance( self->s.pos.trBase, target->s.pos.trBase ) > LEVEL2_CLAW_RANGE)
					self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
				else if(botTargetInRange( self, target ))
					self->client->pers.cmd.buttons |= BUTTON_ATTACK;
			}
			else if (self->client->pers.classSelection == PCL_ALIEN_LEVEL3)//dragon
			{
				if(Distance( self->s.pos.trBase, target->s.pos.trBase ) > 150 && 
					self->client->ps.stats[ STAT_MISC ] < LEVEL3_POUNCE_SPEED)
					self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
				else if(botTargetInRange( self, target))
					self->client->pers.cmd.buttons |= BUTTON_ATTACK;
			}
			else if (self->client->pers.classSelection == PCL_ALIEN_LEVEL3_UPG)//adv dragon
			{
			         //int ammo;
				 //int clips;
			         //BG_UnpackAmmoArray( WP_ALEVEL3_UPG, self->client->ps.ammo, self->client->ps.powerups,&ammo, &clips );
				if(self->client->ps.ammo[WP_ALEVEL3_UPG] > 0 && 
					Distance( self->s.pos.trBase, target->s.pos.trBase ) > 150 )
					self->client->pers.cmd.buttons |= BUTTON_USE_HOLDABLE;
				else
				{	
					if(Distance( self->s.pos.trBase, target->s.pos.trBase ) > 150 && 
						self->client->ps.stats[ STAT_MISC ] < LEVEL3_POUNCE_UPG_SPEED)
						self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
					else if(botTargetInRange(self, target))
						self->client->pers.cmd.buttons |= BUTTON_ATTACK;
				}
			}
			else if (self->client->pers.classSelection == PCL_ALIEN_LEVEL4)//tyrant
			{
				if (Distance( self->s.pos.trBase, target->s.pos.trBase ) > LEVEL4_CLAW_RANGE)
					self->client->pers.cmd.buttons |= BUTTON_ATTACK2;
				else if(botTargetInRange(self, target))
					self->client->pers.cmd.buttons |= BUTTON_ATTACK;
			} else
                            self->client->pers.cmd.buttons |= BUTTON_ATTACK;
                        
	} else if( self->client->ps.stats[STAT_PTEAM] == PTE_HUMANS ) {
	    if(self->client->ps.weapon == WP_FLAMER)
	    {
		if(Distance( self->s.pos.trBase, target->s.pos.trBase ) < 200)
		    self->client->pers.cmd.buttons |= BUTTON_ATTACK;
		
	    } else if( self->client->ps.weapon == WP_LUCIFER_CANNON ) {
                
		if( self->client->time10000 % 2000 ) {
		    self->client->pers.cmd.buttons |= BUTTON_ATTACK;
                    self->isFireing = qtrue;
                }
                    
		    
            } else
            self->client->pers.cmd.buttons |= BUTTON_ATTACK;
            
        }

        return qtrue;
    }
    return qfalse;
}

qboolean botTargetInRange( gentity_t *self, gentity_t *target ) {
    trace_t trace;
    gentity_t *traceEnt;
    float width = 1;
    float range = 100;
    vec3_t    end;
    vec3_t    mins, maxs;
    vec3_t  muzzle;
    vec3_t  forward, right, up;
    if(self->client->ps.stats[STAT_PTEAM] == PTE_ALIENS) {
	
	//find the range and width of alien attack
	switch(self->client->pers.classSelection) {
	    case PCL_ALIEN_LEVEL0:
		range = LEVEL0_BITE_RANGE;
		width = LEVEL0_BITE_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL1:
		range = LEVEL1_CLAW_RANGE;
		width = LEVEL1_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL1_UPG:
		range = LEVEL1_CLAW_RANGE;
		width = LEVEL1_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL2:
		range = LEVEL2_CLAW_RANGE;
		width = LEVEL2_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL2_UPG:
		range = LEVEL2_CLAW_RANGE;
		width = LEVEL2_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL3:
		range = LEVEL3_CLAW_RANGE;
		width = LEVEL3_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL3_UPG:
		range = LEVEL3_CLAW_RANGE;
		width = LEVEL3_CLAW_WIDTH;
		break;
	    case PCL_ALIEN_LEVEL4:
		range = LEVEL4_CLAW_RANGE;
		width = LEVEL4_CLAW_WIDTH;
		break;
	    default: return qfalse;
	}
	
	//draw line between us and the target and see what we hit
	//G_WideTrace( &trace, self, range, width, &traceEnt );
	 

	
	
    } else if(self->client->pers.teamSelection == PTE_HUMANS) {
	switch(self->client->ps.weapon) {
	  case WP_PAIN_SAW:
	    range = PAINSAW_RANGE;
	  case WP_FLAMER:
	    range = FLAMER_LIFETIME * FLAMER_SPEED / 1000;
	  default: 
	    range = 8192 * 16;
	}
	width = 1;
    } else if( self->s.eType == ET_BUILDABLE ) {
            switch(self->s.modelindex) {
                case BA_H_MGTURRET:
                    range = MGTURRET_RANGE;
                case BA_H_TESLAGEN:
                    range = TESLAGEN_RANGE;
                case BA_H_REACTOR:
                    range = REACTOR_ATTACK_RANGE;
                case BA_A_ACIDTUBE:
                    range = ACIDTUBE_RANGE;
                case BA_A_HIVE:
                    range = HIVE_RANGE;
                case BA_A_OVERMIND:
                    range = OVERMIND_ATTACK_RANGE;
                default:
                    range = 0;
            }
            width = 1;
    }
    VectorSet( mins, -width, -width, -width );
        VectorSet( maxs, width, width, width );
// set aiming directions
	AngleVectors( self->client->ps.viewangles, forward, right, up );

	CalcMuzzlePoint( self, forward, right, up, muzzle );

	VectorMA( muzzle, range, forward, end );

	G_UnlaggedOn( self, muzzle, range );
	trap_Trace( &trace, muzzle, mins, maxs, end, self->s.number, MASK_SHOT );
	G_UnlaggedOff( );

	if( trace.surfaceFlags & SURF_NOIMPACT )
	    return qfalse;

	traceEnt = &g_entities[ trace.entityNum ];

	if( traceEnt == target && traceEnt->takedamage)
	    return qtrue;
	return qfalse;
}

//Begin node/waypoint/path functions
int distanceToTargetNode( gentity_t *self )
{
        int distance,Ax,Ay,Az,Bx,By,Bz = 0;
        Ax = level.paths[self->targetPath].coord[0];
        Ay = level.paths[self->targetPath].coord[1];
        Az = level.paths[self->targetPath].coord[2];
        Bx = self->s.pos.trBase[0];
        By = self->s.pos.trBase[1];
        Bz = self->s.pos.trBase[2];
        distance = sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz));
        return distance;
}
qboolean botAimAtPath( gentity_t *self )
{
        vec3_t dirToTarget, angleToTarget;
        vec3_t top = { 0, 0, 0};
        int vh = 0;
        BG_FindViewheightForClass(  self->client->ps.stats[ STAT_PCLASS ], &vh, NULL );
        top[2]=vh;
        VectorAdd( self->s.pos.trBase, top, top);
        
        VectorSubtract( level.paths[self->targetPath].coord, top, dirToTarget );
        if( dirToTarget[2] < 0)
        dirToTarget[2] = 0;
        VectorNormalize( dirToTarget );
        vectoangles( dirToTarget, angleToTarget );
        self->client->ps.delta_angles[ 0 ] = ANGLE2SHORT( angleToTarget[ 0 ] );
        self->client->ps.delta_angles[ 1 ] = ANGLE2SHORT( angleToTarget[ 1 ] );
        return qtrue;
}
void findnewpath( gentity_t *self )
{
        trace_t trace;
        int i,distance,Ax,Ay,Az,Bx,By,Bz = 0;
        int closestpath = 0;
        int closestpathdistance = 2000;
        qboolean pathfound = qfalse;
        self->lastpathid = -1;
        for(i = 0; i < level.numPaths; i++) //find a nearby path that wasn't used before
        {
                trap_Trace( &trace, self->s.pos.trBase, NULL, NULL, level.paths[i].coord, self->s.number, MASK_SHOT );
                if( trace.fraction < 1.0 )
                {continue;}
                Ax = level.paths[i].coord[0];
                Ay = level.paths[i].coord[1];
                Az = level.paths[i].coord[2];
                Bx = self->s.pos.trBase[0];
                By = self->s.pos.trBase[1];
                Bz = self->s.pos.trBase[2];
                distance = sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz));
                if(distance < 5000)
                {
                        if(closestpathdistance > distance)
                        {
                                closestpath = i;
                                closestpathdistance = distance;
                                pathfound = qtrue;
                        }
                }
        }
        if(pathfound == qtrue)
        {
                self->targetPath = closestpath;
                self->timeFoundPath = level.time;
                self->state = TARGETPATH;
                self->isblocked = qfalse;
        }
        else
        {
                self->state = LOST;
                self->client->pers.cmd.forwardmove = 0;
                self->client->pers.cmd.upmove = -1;
                self->client->pers.cmd.rightmove = 0;
                self->client->pers.cmd.buttons = 0;
                self->client->pers.cmd.buttons |= BUTTON_GESTURE;
        }
        return;
}
void findnextpath( gentity_t *self )
{
        int randnum = 0;
        int i,nextpath = 0;
        int possiblenextpath = 0;
        int possiblepaths[5];
        int lasttarget = self->targetPath;
        possiblepaths[0] = possiblepaths[1] = possiblepaths[2] = possiblepaths[3] = possiblepaths[4] = 0;
        for(i = 0; i < 5; i++)
        {
                if(level.paths[self->targetPath].nextid[i] < level.numPaths &&
                        level.paths[self->targetPath].nextid[i] >= 0)
                {
                        if(self->lastpathid >= 0)
                        {
                                if(self->lastpathid == level.paths[self->targetPath].nextid[i])
                                {
                                        continue;
                                }
                        }
                        possiblepaths[possiblenextpath] = level.paths[self->targetPath].nextid[i];
                        possiblenextpath++;
                }
        }
        if(possiblenextpath == 0)
        {       
                self->state = FINDNEWPATH;
                return;
        }
        else
        {
                self->state = TARGETPATH;
                if(level.paths[self->targetPath].random < 0)
                {
                        nextpath = 0;
                }
                else
                {
                        srand( trap_Milliseconds( ) );
                        randnum = (int)(( (double)rand() / ((double)(RAND_MAX)+(double)(1)) ) * possiblenextpath);
                        nextpath = randnum;
                        //if(nextpath == possiblenextpath)
                        //{nextpath = possiblenextpath - 1;}
                }
                self->lastpathid = self->targetPath;
                self->targetPath = possiblepaths[nextpath];
                for(i = 0;i < 5;i++)
                {
                        if(level.paths[self->targetPath].nextid[i] == lasttarget)
                        {
                                i = 5;
                        }
                }

                self->timeFoundPath = level.time;
                return;
        }
        return;
}
void pathfinding( gentity_t *self )
{
        switch(self->state)
        {
                case FINDNEWPATH: findnewpath(self); break;
                case FINDNEXTPATH: findnextpath(self); break;
                case TARGETPATH: break; //done in G_FrameThink
                case LOST: findnewpath(self);break; //LOL :(
                default: break;
        }
}
/*void botGotoTarget( gentity_t *self ) {
    gentity_t *target;
    int paths[MAX_PATHS];
    int i;
    int numpaths;
    
    if(self->botEnemy)
        target = self->botEnemy;
    else if(self->botTarget)
        target = self->botTarget;
    else
        return;
    findnewpath( target );
    for(i = 0; i<MAX_PATHS;i++) {
        paths[i] = target->targetPath;
        if(target->targetPath != self->targetPath && target->targetPath != self->lastpathid) {
            
            if(target->state == FINDNEXTPATH)
            findnextpath(target);
            else
            findnewpath(target);
        } else {
            numpaths = i;
            i = MAX_PATHS;
        }
    }
    self->lastpathid = self->targetNode;
    self->targetNode = numpaths;
    for( i = numpaths; i > 0;i--) {
        while(distanceToTargetNode( self) < 70) {
        botAimAtPath( self );
        self->client->pers.cmd.forwardmove = 127;

        self->client->pers.cmd.rightmove = -100;
        if(self->client->time1000 >= 500 && random() < 0.7)
            self->client->pers.cmd.rightmove = 100;
        }
        self->lastpathid = self->targetNode;
        self->targetNode = i - 1;
    }
}*/
/*int findPathToTarget( gentity_t *self ) {
    gentity_t *target;
    
    int i, k, mini;
    int n = level.numPaths;
        int visited[MAX_PATHS];
        long d[MAX_PATHS];
        int s;
        if(self->botEnemy) {
       target = self->botEnemy;
        }else if(self->botTarget){
        target = self->botTarget;
        }else{
        return 0;
        }
        findnewpath(target);
        s = self->targetPath;
    
    

        for (i = 1; i <= n; ++i) {
                d[i] = 999999999;
                prev[i] = -1; no path has yet been found to i
                visited[i] = 0; the i-th element has not yet been visited
        }

        d[s] = 0;

        for (k = 1; k <= n; ++k) {
                mini = -1;
                for (i = 1; i <= n; ++i)
                        if (!visited[i] && ((mini == -1) || (d[i] < d[mini])))
                                mini = i;

                visited[mini] = 1;

                for (i = 1; i <= n; ++i)
                        if (distanceBetweenNodes(mini,i))
                                if (d[mini] + distanceBetweenNodes(mini,i) < d[i]) {
                                        d[i] = d[mini] + distanceBetweenNodes(mini,i);
                                        prev[i] = mini;
                                }
        }
            return makePath(target->targetPath, 0, self);
}*/
void findPathToTarget( gentity_t *self ) {
    long shortdist[MAX_PATHS];
    //int numNodes = MAX_PATHS;
    short i;
    short k;
    short n;
    int mini;
    short path[MAX_PATHS];
    short visited[MAX_PATHS];
    int minDistance = 9999999;
    int minDistance2 = 9999999;
    short startNum = 0;
    short endNum = 0;
    //path levelpaths[MAX_PATHS];
    vec3_t start = {0,0,0}; 
    vec3_t end = {0,0,0};
    //start = self->s.pos.trBase;
    VectorCopy( self->s.pos.trBase, start );
    
    if(self->botEnemy)
    VectorCopy( self->botEnemy->s.pos.trBase, end);
    else
    VectorCopy( self->botTarget->s.pos.trBase, end);
    //setup array of the distances
    /*for(i=0;i<level.numPaths;i++) {
        for(k=0;k<level.numPaths;k++) {
            for(n=0;n<5;n++){
                if(level.paths[i].nextid[n] == k)
                    distances[i][k] = distanceBetweenNodes(level.paths[i],level.paths[k]);
                else
                    distances[i][k] = 0;
            }
        }
    }*/
    for( i=0;i<MAX_PATHS;i++) {
        shortdist[i] = 99999999;
        path[i] = -1;
        visited[i] = 0;
        //levelpaths[i] = level.paths[i];
        if( Distance(start, level.paths[i].coord) + abs(start[2] - level.paths[i].coord[2])*3< minDistance) {
           minDistance = Distance( start, level.paths[i].coord );
           startNum = i;
        }
        if( Distance(end, level.paths[i].coord) + abs(end[2] - level.paths[i].coord[2])*3< minDistance2) {
           minDistance2 = Distance( end, level.paths[i].coord );
           endNum = i;
        }
    }
    //for( i = level.numPaths + 1;i<= level.numPaths + 2;i++) {
        /*level.paths[level.numPaths].coord[0] = start[0];
        level.paths[level.numPaths].coord[1] = start[1];
        level.paths[level.numPaths].coord[2] = start[2];
        level.paths[level.numPaths].nextid[0] = startNum;
        level.paths[level.numPaths + 1].coord[0] = end[0];
        level.paths[level.numPaths + 1].coord[1] = end[1];
        level.paths[level.numPaths + 1].coord[2] = end[2];
        level.paths[level.numPaths + 1].nextid[0] = endNum;*/
        
    shortdist[endNum] = 0;
    for (k = 0; k <= MAX_PATHS; ++k) {
        mini = -1;
        for (i = 0; i <= MAX_PATHS; ++i) {
            if (!visited[i] && ((mini == -1) || (shortdist[i] < shortdist[mini])))
                mini = i;
        }

        visited[mini] = 1;

        for (i = 0; i <= MAX_PATHS; ++i) {
            if (level.distNode[mini][i]) {
                if (shortdist[mini] + level.distNode[mini][i] < shortdist[i]) {
                    shortdist[i] = shortdist[mini] + level.distNode[mini][i];
                    path[i] = mini;
                }
            }
        }
    }
        /* //get rid of -1 digits
        for(k=0;k<level.numPaths; ++k) {
            if(path[i] != -1) {
                self->pathToTarget[numElements] = path[i];
                numElements++;
            }
        }
        //flip the array so it reads forward 2 back instead of back 2 forward
        for(i=0;i<numElements; ++1) {
            path[i] = self->pathToTarget[numElements-i];
            self->pathToTarget[i] = path[*/
        //i=0;
        //self->pathToTarget[i] = endNum;
        //trap_SendServerCommand(-1, va("print ^7%d is a node in path\n", endNum));
        //trap_Printf( va("'^7%d' is a node in path", endNum) );
        trap_SendServerCommand(-1,"print ^7 DOES THIS EVEN WORK\n");
        for(i=0;i<level.numPaths;i++) {
            //trap_Printf( va("'^7%d' is a node in path", path[endNum]) );
            //trap_SendServerCommand(-1, va("print ^7%d is a node in path\n", path[endNum]));
            self->pathToTarget[i] = path[i];
            //endNum = path[endNum];
           // i++;
        }
        
        self->pathSize = startNum;
        
        /*//copy array into global
        for(k=0;k<level.numPaths; ++k) {
            self->pathToTarget[k] = path[k];
        }*/
}
            
    
qboolean arePathsConnected( int path1, int path2) {
    trace_t trace;
        trap_Trace( &trace, level.paths[path1].coord, NULL, NULL, level.paths[path2].coord, path1, MASK_SHOT );
        if( trace.fraction < 1.0f )
            return qfalse;
        return qtrue;
}
        
int makePath( int dest, int num, gentity_t *self ) {
    if( prev[dest] != -1 && prev[dest] != self->targetPath) {
        self->pathToTarget[num] = prev[dest];
        num++;
        num = makePath(prev[dest], num, self);
    }
    return num;
}
        
    
int distanceBetweenVectors( vec3_t node1, vec3_t node2 )
{
        int distance,Ax,Ay,Az,Bx,By,Bz = 0;
        Ax = node1[0];
        Ay = node1[1];
        Az = node1[2];
        Bx = node2[0];
        By = node2[1];
        Bz = node2[2];
        distance = sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz));
        return distance;
}
qboolean nodesAreConnected( int node1, int node2 ) {
    if( level.paths[node1].nextid[0] == node2)
        return qtrue;
    else if( level.paths[node1].nextid[1] == node2)
        return qtrue;
    else if(  level.paths[node1].nextid[2] == node2)
        return qtrue;
    else if(  level.paths[node1].nextid[3] == node2)
        return qtrue;
    else if( level.paths[node1].nextid[4] == node2)
        return qtrue;
    else
        return qfalse;
}
    
